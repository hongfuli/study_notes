# 备库为什么会延迟好几个小时？

因为 MySQL 有 MMVC，支持多版本和行锁，所以对并行度支持是很好的，但是如果备库的 sql\_thread 是单线程执行的话，那么执行总体速度是赶不上主库的。

MySQL 针对这个问题引入了多线程复制。通过 `slave_parallel_workers` 控制线程数，如果是 32 核，一般分配 8 ~ 16 之间。

大概思路是，有一个 coordinator 专门负责解析 binlog 事务日志并分发给 work 线程。这个分发工作不能随便分发，需要一些限制：

1. 如果更新同一行数据，则需要分发到同一个 work 中。不然不同的并行 work 没法控制本来的执行顺序。
1. 同一个事务多条语句不能分开，不然可见性会不一致。

一些分发策略:

## 按表
相同表的操作分配到一个 work。

## 按行
相同的行操作分配到一个 work。这里需要根据所有唯一字段来做行标识计算，比如主键，唯一索引都要考虑。

而且，因为需要解析 binlog 的数据修改前后的值，所以 `binlog_format` 是 row 格式。

## 按库
好处是内部维护的 hash 数据少，因为只需要计算库的参数。坏处也明显，现在大家一般一个实例也只放一个库，所以基本还是单线程复制。


