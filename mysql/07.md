# 行锁功过：怎么减少行锁对性能的影响？

## 2PL
因为事务中对多行上锁使用的 2PL (最事务结束前，无论 commit/rollback，都不会释放任何行锁)，所以最好把**访问最频繁**的行数据最后上锁。

2PL 为了满足 Serializable ，有一个原则是：在 Locked Point 前不会释放任何行锁，这个会导致可能死锁（deadlock）。InnoDB 解决死锁有两个方案：

1. 等待超时。通过这个参数 `innodb_lock_wait_timeout` 来控制等待超时时间。缺点：太长了系统基本不可用；少短了会误伤正常需要等待业务，比如用户余额流水上锁。
1. 检测死锁。通过 `innodb_deadlock_detect` 来开关。默认是 on。死锁的条件就是检测是否线程的等待依赖关系构成了循环图，所以当并发达到一定量级后，这个计算复杂度是很高的。

上面说的两个办法都有缺点，怎么破？
文中给出的解决思路是减少并发，如果有数据库专家，可以在 MySQL 内部修改并行控制。如果在业务层做，可以分散热点数据，但是这会增加业务代码复杂度。
