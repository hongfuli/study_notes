# count(\*)这么慢，我该怎么办？

结论：

```
count(*) == count(1) > count(主键 id ) > count(字段)

```

分析：

count 说到底就是个普通聚合计算函数，根据参数传入的值是为 NULL 来累加。这个参数是 server 层找引擎层要，引擎把满足条件的值逐行返回聚合计算。

count(\*) 做了专门优化，虽然 `*` 字符看起来返回所有数据，但是优化器并不实际返回任何数据，只是按行统计。

count(1) 和 count(\*) 差不多，都不实际取值，每扫描一行传常量 1  值。所以性能基本一样。

count(字段) 需要加载每一行数据并取出指定字段值，判断是为 NULL 来决定是否累加。所以这个性能是最差的，因为整行数据都加载了。

count(主键) 和 count(字段) 区别是前者不用加载整行数据，而只是取出 pk 值即可，这在很多二级索引树上做计算时不用回主索引检索数据。


## 怎么加速
count() 函数是逐行统计，看起来很傻，为什么不冗余一个统计量呢？因为事务，因为 MVCC。

对于某些业务场景，每次搜索表求 count 太慢的话，有一些方案：

1. 自已缓存冗余（比如 Redis），和数据库操作同步更新。
1. 在数据库添加一个行数统计表。

这两个方案没有谁最佳，就是性能和准确的平衡。和数据库一起存储，可以保证同一个事务操作，所以一致性可能满足。自己用高速缓存，性能好，但是又引入分布式事务。

